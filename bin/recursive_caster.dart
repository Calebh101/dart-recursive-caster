import 'dart:io';

import 'package:args/args.dart';
import 'package:collection/collection.dart';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart';

bool isVerbose = false;
Map<String, String?> prefixLookup = {};

void verbose(Object? input) {
  if (!isVerbose) return;
  print("Verbose: $input");
}

void warn(Object? input) {
  print("Warning: $input");
}

void main(List<String> arguments) {
  Directory root = Directory.current;
  print("Starting recursive_caster...");

  ArgParser parser = ArgParser()
    ..addOption("project-root", help: "Root of your project. This defaults to the current working directory.")
    ..addOption("library-directory", help: "The directory that the generated library file will be placed. This is relative to the project root.", defaultsTo: "lib")
    ..addFlag("help", abbr: "h", help: "Show usage.")
    ..addFlag("verbose", abbr: "v", help: "Show extra logs. This is helpful in debugging.")
    ..addFlag("compact", help: "Strip comments and line breaks from the generated library file.");

  ArgResults args = (() {
    try {
      ArgResults parsed = parser.parse(arguments);
      return parsed;
    } on FormatException catch (e) {
      print("");
      print("${e.message}\n\nUsage:\n${parser.usage}");
      exit(1);
    }
  })();

  if (args["help"] == true) {
    print("");
    print("Usage:\n${parser.usage}");
    exit(0);
  }

  if (args["verbose"] == true) {
    isVerbose = true;
    verbose("Enabling verbose...");
  }

  try {
    String given = args["project-root"]!;
    Directory newDir = Directory(given);
    if (newDir.existsSync()) root = newDir;
  } catch (e) {
    //
  }

  String libdir = args["library-directory"];
  Directory lib = Directory(p.joinAll([root.path, libdir]));
  File file = File(p.joinAll([lib.path, "recursive_caster.g.dart"]));
  File settingsFile = File(p.joinAll([root.path, "recursive_caster.yaml"]));
  print("Using library directory ${lib.path}...");

  if (FileStat.statSync(p.joinAll([root.path, "pubspec.yaml"])).type == FileSystemEntityType.notFound) {
    print("The specified root directory is not a Dart project with a valid pubspec.yaml.");
    exit(1);
  }

  if (!settingsFile.existsSync()) {
    print("The specified project does not contain a valid recursive_caster settings file. Please run:\n   dart run recursive_caster.dart:initialize\nOr add the settings file yourself at ${settingsFile.path}.");
    exit(1);
  }

  if (!lib.existsSync()) {
    print("The specified library directory ($libdir) does not exist at ${lib.path}.");
    exit(1);
  }

  print("Loading settings...");
  Map settings = loadYaml(settingsFile.readAsStringSync());

  verbose("Loading inputted types...");
  List<String> types = ((settings["types"] as List?) ?? []).whereType<String>().toList();

  verbose("Loading inputted imports...");
  List<String> importsData = ((settings["imports"] as List?) ?? []).whereType<String>().toList();

  verbose("Loading inputted prefixes...");
  YamlMap prefixData = (settings["prefixes"] ?? YamlMap());
  Map<String, Map<String, dynamic>> data = {};
  List<TypeId> foundTypes = [];
  print("Loading types...");

  prefixLookup = Map.fromEntries(
    prefixData.entries.map(
      (e) => MapEntry(e.key.toString(), e.value?.toString()),
    ),
  );

  for (String typeString in types) {
    TypeId type = processTypes(typeString);
    String function = getMapFunction(type);
    foundTypes.add(type);

    data[type.toRawString()] = {
      "function": function,
      "libraries": type.getAllLibraries(),
    };
  }

  print("Loading imports...");
  List<Import> imports = getImportLines(importsData);
  bool anyDeferred = imports.any((x) => x.deferred);

  if (anyDeferred) {
    warn("Deferred imports aren't available! Falling back to static imports...");
  }

  List<Line> lines = [
    // Comments
    Line.comment("This file is auto-generated by recursive_caster.", tabs: 0),
    Line.comment("It's recommended to add this file to your gitignore, as it can be regenerated using your configuration file.", tabs: 0),
    Line.space(overrideSpace: true),
    Line.comment("Any modifications to this file are not saved. If you need customizations that this package doesn't provide, feel free to make an issue or pull request on GitHub.", tabs: 0),
    Line.comment("You shouldn't try to read this file, as it'll be harder to follow than the actual generator script.", tabs: 0),

    // Start generation and include required imports.
    ...(Line.space(overrideSpace: true) * 3),
    Line.comment("-------------------- START GENERATION --------------------", tabs: 0, doubleSided: true),
    ...imports.map((x) => x.line).whereType<Line>(),

    // Declare [RecursiveCaster] class (and privatize constructor). Then add DartDoc documentation.
    Line.comment("This is the main class for the casting library.", tabs: 0, dartdoc: true),
    Line("class RecursiveCaster {", tabs: 0),
    Line("RecursiveCaster._();", tabs: 1),
    Line.comment("This function is the bridge to the generated casting code and your code. [T] is the type you are requesting the conversion to. If [T] is not in the generated list, then a [RecursiveCasterTypeError] is thrown. Currently supported types are:", tabs: 1, dartdoc: true),
    Line.commentSpace(tabs: 1, dartdoc: true),

    // Generate list of supported types in the DartDoc.
    ...List.generate(foundTypes.length, (i) {
      TypeId type = foundTypes[i];
      String string(bool prefix) => type.toRawString(showPrefix: prefix);
      return Line.comment("- [${string(false)}] (`${string(false)}`)", tabs: 1, dartdoc: true);
    }),

    // Declare the main casting function. We use a series of if checks to check if the type matches. If all else fails, we'll throw a RecursiveCasterTypeError.
    Line("static T cast<T>(Object? input) {", tabs: 1),

    ...List.generate(data.length, (i) {
      MapEntry<String, Map<String, dynamic>> entry = data.entries.toList()[i];
      String function = entry.value["function"];
      return Line('if (T == ${entry.key}) return ($function)(input) as T;', tabs: 2);
    }),

    Line('throw RecursiveCasterTypeError(T);', tabs: 2),
    Line("}", tabs: 1),

    // Declare the getAll function, which returns the keys of _data.
    Line.comment("This function returns an [Iterable<Type>] of all types supported by your configuration.", tabs: 1, dartdoc: true),
    Line("static Iterable<Type> getAll() => [${foundTypes.map((type) => type.toRawString()).join(", ")}];", tabs: 1),
    Line("}", tabs: 0),

    // Declare RecursiveCasterTypeError error, which is called if the casting object is not defined for the specified type.
    Line.comment("This error is called if a casting object is not defined for the specified type.", tabs: 0, dartdoc: true),
    Line("class RecursiveCasterTypeError extends Error {", tabs: 0),
    Line.comment("The type that was specified.", tabs: 1, dartdoc: true),
    Line("final Type type;", tabs: 1),
    Line.comment("This error is called if a casting object is not defined for the specified type.", tabs: 1, dartdoc: true),
    Line.commentSpace(tabs: 1, dartdoc: true),
    Line.comment("[type] is the type that was specified.", tabs: 1, dartdoc: true),
    Line("RecursiveCasterTypeError(this.type);", tabs: 1),
    Line("@override", tabs: 1),
    Line('String toString() => "RecursiveCasterTypeError: Could not find type \$type to be casted. (Did you forget to add the type to your configuration?)";', tabs: 1),
    Line("}", tabs: 0),
  ];

  verbose("Generated ${lines.length} pseudo-lines...");
  print("Writing out file...");
  file.writeAsStringSync(lines.process(ultraCompact: args["compact"] == true));
}

extension on Line {
  List<Line> operator *(int other) {
    return List.generate(other, (i) => this);
  }
}

TypeId processTypes(String typeString) {
  verbose("Processing type $typeString...");
  TypeId processed = parseType(typeString, 0).type;
  verbose("Processed type ${processed.toRawString()}");
  return processed;
}

TypeIdResult parseType(String string, int start) {
  String buffer = "";
  List<TypeId> children = [];
  int i = start;

  while (i < string.length) {
    String char = string[i];
    int code = char.codeUnitAt(0);

    bool isUppercase = code >= 65 && code <= 90;
    bool isLowercase = code >= 97 && code <= 122;
    bool isDigit = code >= 48 && code <= 57;
    bool isUnderscore = code == "_".codeUnitAt(0);
    bool isPeriod = code == ".".codeUnitAt(0);
    bool isOpeningBracket = code == "<".codeUnitAt(0);
    bool isClosingBracket = code == ">".codeUnitAt(0);
    bool isComma = code == ",".codeUnitAt(0);

    if (isUppercase || isLowercase || isDigit || isUnderscore || isPeriod) { 
      verbose("Continuing with character at index $i... (at: $start)");
      buffer += char;
      i++;
    } else if (isOpeningBracket) {
      verbose("Repeating with character at index $i... (at: $start)");
      i++;

      while (i < string.length && string[i] != '>') {
        TypeIdResult result = parseType(string, i);
        children.add(result.type);
        i = result.i;
        if (i < string.length && string[i] == ',') i++;
      }

      i++;
    } else if (isClosingBracket || isComma) {
      verbose("Breaking with character at index $i... (at: $start)");
      break;
    } else {
      i++;
    }
  }

  return TypeIdResult(TypeId(buffer, children), i);
}

String getMapFunction(TypeId type) {
  return "(dynamic value) => ${generateValueConversion(type, "value")}";
}

String generateValueConversion(TypeId type, String variable) {
  // Reserved variables:
    // e: Map, List, Set
    // a: Map

  String base = type.type.toLowerCase();

  if (base == "map") {
    TypeId key = type.children[0];
    TypeId value = type.children[1];

    return "Map<${key.toRawString()}, ${value.toRawString()}>.from($variable.map((e, a) => MapEntry(${generateValueConversion(key, "e")}, ${generateValueConversion(value, "a")})))";
  } else if (base == "list") {
    TypeId child = type.children[0];
    return "($variable as List).map((e) => ${generateValueConversion(child, "e")}).toList()";
  } else if (base == "set") {
    TypeId child = type.children[0];
    return "($variable as Set).map((e) => ${generateValueConversion(child, "e")}).toSet()";
  } else {
    return "$variable as ${type.toRawString()}";
  }
}

List<Import> getImportLines(List<String> imports, {int tabs = 0}) {
  // Syntax will be: package:example/example.dart [as prefix] [show Class1, Class2]
  print("Processing imports...");

  List<Import> result = [];
  String quote = "(?:['\"`])?";
  String any1 = "[A-Za-z0-9:_./]+";
  RegExp regex = RegExp("(?:import )?$quote($any1)$quote(?:( deferred)? as $quote($any1)$quote)?(?: show ([A-Za-z0-9:_.,\"'`/ ]+))?");
  verbose("Using import regex '${regex.pattern}'...");

  for (String import in imports) {
    RegExpMatch? match = regex.allMatches(import).firstOrNull;

    if (match == null || match.groupCount <= 0) {
      print("Unable to process import '$import'! ${match == null ? "No match was found for regex '${regex.pattern}'." : "No groups were found in the first match for regex '${regex.pattern}'."}");
      continue;
    }

    String path = match.group(1)!;
    String? prefix = match.group(3);
    String? showLine = match.group(4);
    List<String> show = [];
    bool deferred = prefix != null && (match.group(2)?.contains("deferred") ?? false); // Deferred is not currently available.

    if (showLine != null) {
      // Remove quotes from matches, separate by commas, trim each new string, then set it to [show] as a list
      show = showLine.replaceAll(RegExp("[\"'`]"), "").split(",").map((x) => x.trim()).toList();
    }

    print("Found import of path '$path', prefix '$prefix'");
    List<String> text = ["import '$path'", if (prefix != null) "as $prefix", if (show.isNotEmpty) "show ${show.join(", ")}", ";"];
    Line line = Line(text.join(" "), tabs: tabs);
    result.add(Import(path, line: line, prefix: prefix, show: show, deferred: deferred));
  }

  return result;
}

class Import {
  final Line? line;
  final String path;
  final String? prefix;
  final List<String> show;
  final bool deferred;

  const Import(this.path, {this.line, this.prefix, this.show = const [], this.deferred = false});
}

class Line {
  final String text;
  final int tabs;

  final bool _isComment;
  final bool _isSpace;
  final bool overrideSpace;

  const Line(this.text, {required this.tabs, this.overrideSpace = false}) : _isComment = false, _isSpace = false;
  const Line.space({this.overrideSpace = false}) : text = "", tabs = 0, _isComment = false, _isSpace = true;
  const Line.comment(String comment, {required this.tabs, bool dartdoc = false, bool doubleSided = false, this.overrideSpace = false}) : text = "${dartdoc ? "/" : ""}// $comment${doubleSided ? " ${dartdoc ? "/" : ""}//" : ""}", _isComment = true, _isSpace = false;
  const Line.commentSpace({required this.tabs, bool dartdoc = false, this.overrideSpace = false}) : text = "${dartdoc ? "/" : ""}//", _isComment = true, _isSpace = true;

  bool get isComment => _isComment;
  bool get isSpace => _isSpace;
}

extension ProcessLines on List<Line> {
  String process({int extraTabs = 0, bool compressed = false, bool removeComments = false, bool ultraCompact = false}) {
    if (ultraCompact) { // This overrides [compressed] and [removeComments].
      compressed = true;
      removeComments = true;
    }

    List<Line> lines = this; // New object (we can't say this = this.where(...))
    if (removeComments) lines = lines.where((x) => !x.isComment).toList(); // This one is just for fun, as users will probably prefer DartDocs.

    if (compressed) { // Make the output file ultra-compact and unreadable.
      List<String> compiled = lines.map((x) => x.isSpace ? (x.overrideSpace ? "\n" : "") : (x.isComment ? "${x.text}\n" : "${x.text} ")).toList();
      return compiled.join("").trim();
    } else {
      String tab = " " * 2; // 2 spaces
      List<String> compiled = lines.map((line) => "${tab * (line.tabs + extraTabs)}${line.text}").toList();
      return compiled.join("\n").trim();
    }
  }
}

class TypeId {
  String type;
  List<TypeId> children;
  String? prefix;

  TypeId(this.type, [List<TypeId>? childs]) : children = childs ?? [], prefix = prefixLookup[type] {
    if (type.isEmpty) throw ArgumentError("Type name cannot be empty.");
  }

  @override
  bool operator ==(Object other) {
    if (other is! TypeId) return false;
    ListEquality equality = ListEquality();
    return type == other.type && equality.equals(children, other.children);
  }
  
  @override
  int get hashCode => type.hashCode ^ children.hashCode;

  @override
  String toString() {
    return "TypeId($type, children: $children)";
  }

  String toRawString({bool showPrefix = true}) {
    return [if (prefix != null && showPrefix) "$prefix.", type, if (children.isNotEmpty) "<${children.map((x) => x.toRawString(showPrefix: showPrefix)).join(", ")}>"].join("");
  }

  String toCamelCaseString({bool capitalizeFirst = false}) {
    List<String> chars = type.split("");
    chars[0] = chars[0].toLowerCase();
    if (capitalizeFirst) chars[0] = chars[0].toUpperCase();
    return [chars.join(""), if (children.isNotEmpty) ...children.map((x) => x.toCamelCaseString(capitalizeFirst: true))].join("");
  }

  String toFullCamelCaseString() {
    String input = toCamelCaseString(capitalizeFirst: true);
    return "to$input";
  }

  /// Possible values:
  /// - `Map`
  /// - `List`
  /// - `Set`
  String getBase() {
    switch (type.toLowerCase()) {
      case "map": return "Map";
      case "list": return "List";
      case "set": return "Set";
      default: return type;
    }
  }

  List<String> getAllLibraries() {
    List<String?> results = [prefix];

    for (TypeId child in children) {
      results.addAll(child.getAllLibraries());
    }

    return results.whereType<String>().toList();
  }
}

class TypeIdResult {
  final TypeId type;
  final int i;
  const TypeIdResult(this.type, this.i);
}