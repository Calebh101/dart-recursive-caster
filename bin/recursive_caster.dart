import 'dart:io';

import 'package:args/args.dart';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart';

bool isVerbose = false;

void verbose(Object? input) {
  if (!isVerbose) return;
  print("Verbose: $input");
}

void main(List<String> arguments) {
  Directory root = Directory.current;
  print("Starting recursive_caster...");

  ArgParser parser = ArgParser()
    ..addOption("project-root", help: "Root of your project. This defaults to the current working directory.");

  ArgResults args = (() {
    try {
      ArgResults parsed = parser.parse(arguments);
      return parsed;
    } on FormatException catch (e) {
      print("${e.message}\n\nUsage:\n${parser.usage}");
      exit(1);
    }
  })();

  try {
    String given = args["project-root"]!;
    Directory newDir = Directory(given);
    if (newDir.existsSync()) root = newDir;
  } catch (e) {
    //
  }

  Directory lib = Directory(p.joinAll([root.path, "lib"]));
  File file = File(p.joinAll([lib.path, "recursive_caster.g.dart"]));
  File settingsFile = File(p.joinAll([root.path, "recursive_caster.yaml"]));
  print("Using library directory ${lib.path}...");

  if (FileStat.statSync(p.joinAll([root.path, "pubspec.yaml"])).type == FileSystemEntityType.notFound || !lib.existsSync()) {
    print("The specified root directory is not a Dart project with a 'lib' folder. ${FileStat.statSync(p.joinAll([root.path, "pubspec.yaml"])).type}:${lib.existsSync()}");
    exit(1);
  }

  if (!settingsFile.existsSync()) {
    print("The specified project does not contain a valid recursive_caster settings file. Please run:\n   dart run recursive_caster.dart:initialize\nOr add the settings file yourself at ${settingsFile.path}.");
    exit(1);
  }

  Map settings = loadYaml(settingsFile.readAsStringSync());
  List<String> types = ((settings["types"] as List?) ?? []).whereType<String>().toList();
  Map<String, String> data = {};

  for (String typeString in types) {
    TypeId type = processTypes(typeString);
    String function = getMapFunction(type);
    data[type.toRawString()] = function;
  }

  List<Line> lines = [
    Line.comment("A library for simplifying recursive casting for objects.", tabs: 0, dartdoc: true),
    Line("library;", tabs: 0),
    Line.space(),

    Line.comment("This file is auto-generated by recursive_caster.", tabs: 0),
    Line.comment("It's recommended to add this file to your gitignore, as it can be regenerated using your configuration file.", tabs: 0),

    Line.space(),
    Line("Map<Type, Function> _data = {", tabs: 0),

    ...List.generate(data.length, (i) {
      MapEntry<String, String> entry = data.entries.toList()[i];
      return Line('${entry.key}: ${entry.value},', tabs: 1);
    }),

    Line("};", tabs: 0),
    Line.comment("This is the main class for the casting library.", tabs: 0, dartdoc: true),
    Line("class RecursiveCaster {", tabs: 0),
    Line("RecursiveCaster._();", tabs: 1),
    Line.comment("This function is the bridge to the generated casting code and your code. [T] is the type you are requesting the conversion to. If [T] is not in the generated list, then an [RecursiveCasterTypeError] is thrown. Currently supported types are:", tabs: 1, dartdoc: true),
    Line.commentSpace(tabs: 1, dartdoc: true),

    ...List.generate(data.length, (i) {
      MapEntry<String, String> entry = data.entries.toList()[i];
      return Line.comment("- `${entry.key}`", tabs: 1, dartdoc: true);
    }),

    Line("static T convert<T>(Object input) {", tabs: 1),
    Line("if (_data.containsKey(T)) {", tabs: 2),
    Line("return _data[T]!(input);", tabs: 3),
    Line("} else {", tabs: 2),
    Line('throw RecursiveCasterTypeError(T);', tabs: 3),
    Line("}", tabs: 2),
    Line("}", tabs: 1),

    Line.comment("This function returns an [Iterable<Type>] of all types supported by your configuration.", tabs: 1, dartdoc: true),
    Line("static Iterable<Type> getAll() => _data.keys;", tabs: 1),
    Line("}", tabs: 0),

    Line.comment("This error is called if a casting object is not defined for the specified type.", tabs: 0, dartdoc: true),
    Line("class RecursiveCasterTypeError extends Error {", tabs: 0),
    Line.comment("The type that was specified.", tabs: 1, dartdoc: true),
    Line("final Type type;", tabs: 1),
    Line.comment("This error is called if a casting object is not defined for the specified type.", tabs: 1, dartdoc: true),
    Line.commentSpace(tabs: 1, dartdoc: true),
    Line.comment("[type] is the type that was specified.", tabs: 1, dartdoc: true),
    Line("RecursiveCasterTypeError(this.type);", tabs: 1),
    Line("@override", tabs: 1),
    Line('String toString() => "RecursiveCasterTypeError: Could not find type \$type to be converted. (Did you forget to add the type to your configuration?)";', tabs: 1),
    Line("}", tabs: 0),
  ];

  print("Writing out file...");
  file.writeAsStringSync(lines.process());
}

TypeId processTypes(String typeString) {
  TypeId processed = parseType(typeString, 0).type;
  print("$processed - ${processed.toRawString()} - ${processed.toCamelCaseString()} - ${processed.toFullCamelCaseString()}");
  return processed;
}

TypeIdResult parseType(String string, int start) {
  String buffer = "";
  List<TypeId> children = [];
  int i = start;

  while (i < string.length) {
    String char = string[i];
    int code = char.codeUnitAt(0);

    bool isUppercase = code >= 65 && code <= 90;
    bool isLowercase = code >= 97 && code <= 122;
    bool isDigit = code >= 48 && code <= 57;
    bool isUnderscore = code == "_".codeUnitAt(0);
    bool isPeriod = code == ".".codeUnitAt(0);
    bool isOpeningBracket = code == "<".codeUnitAt(0);
    bool isClosingBracket = code == ">".codeUnitAt(0);
    bool isComma = code == ",".codeUnitAt(0);

    if (isUppercase || isLowercase || isDigit || isUnderscore || isPeriod) { 
      verbose("Continuing with character at index $i... (at: $start)");
      buffer += char;
      i++;
    } else if (isOpeningBracket) {
      verbose("Repeating with character at index $i... (at: $start)");
      i++;

      while (i < string.length && string[i] != '>') {
        TypeIdResult result = parseType(string, i);
        children.add(result.type);
        i = result.i;
        if (i < string.length && string[i] == ',') i++;
      }

      i++;
    } else if (isClosingBracket || isComma) {
      verbose("Breaking with character at index $i... (at: $start)");
      break;
    } else {
      i++;
    }
  }

  return TypeIdResult(TypeId(buffer, children), i);
}

String getMapFunction(TypeId type) {
  return "(${type.getBase()} value) => ${generateValueConversion(type, "value")}";
}

String generateValueConversion(TypeId type, String variable) {
  String base = type.type.toLowerCase();

  if (base == "map") {
    TypeId key = type.children[0];
    TypeId value = type.children[1];

    return "Map<${key.toRawString()}, ${value.toRawString()}>.from($variable.map((k, v) => MapEntry(k as ${key.toRawString()}, ${generateValueConversion(value, "v")})))";
  } else if (base == "list") {
    TypeId child = type.children[0];
    return "($variable as List).map((e) => ${generateValueConversion(child, "e")}).toList()";
  } else if (base == "set") {
    TypeId child = type.children[0];
    return "($variable as Set).map((e) => ${generateValueConversion(child, "e")}).toSet()";
  } else {
    return "$variable as ${type.toRawString()}";
  }
}

class Line {
  final String text;
  final int tabs;

  const Line(this.text, {required this.tabs});
  const Line.space() : text = "", tabs = 0;
  const Line.comment(String comment, {required this.tabs, bool dartdoc = false}) : text = "${dartdoc ? "/" : ""}// $comment";
  const Line.commentSpace({required this.tabs, bool dartdoc = false}) : text = "${dartdoc ? "/" : ""}//";
}

extension ProcessLines on List<Line> {
  String process({int extraTabs = 0}) {
    String tab = " " * 2;
    List<String> compiled = map((line) => "${tab * (line.tabs + extraTabs)}${line.text}").toList();
    return compiled.join("\n");
  }
}

class TypeId {
  String type;
  List<TypeId> children;

  TypeId(this.type, [List<TypeId>? childs]) : children = childs ?? [] {
    if (type.isEmpty) throw ArgumentError("Type name cannot be empty.");
  }

  @override
  bool operator ==(Object other) {
    if (other is! TypeId) return false;
    return type == other.type;
  }
  
  @override
  int get hashCode => type.hashCode ^ children.hashCode;

  @override
  String toString() {
    return "TypeId($type, children: $children)";
  }

  String toRawString() {
    return [type, if (children.isNotEmpty) "<${children.map((x) => x.toRawString()).join(", ")}>"].join("");
  }

  String toCamelCaseString({bool capitalizeFirst = false}) {
    List<String> chars = type.split("");
    chars[0] = chars[0].toLowerCase();
    if (capitalizeFirst) chars[0] = chars[0].toUpperCase();
    return [chars.join(""), if (children.isNotEmpty) ...children.map((x) => x.toCamelCaseString(capitalizeFirst: true))].join("");
  }

  String toFullCamelCaseString() {
    String input = toCamelCaseString(capitalizeFirst: true);
    return "to$input";
  }

  /// Possible values:
  /// - `Map`
  /// - `List`
  /// - `Set`
  String getBase() {
    switch (type.toLowerCase()) {
      case "map": return "Map";
      case "list": return "List";
      case "set": return "Set";
      default: return type;
    }
  }
}

class TypeIdResult {
  final TypeId type;
  final int i;
  const TypeIdResult(this.type, this.i);
}